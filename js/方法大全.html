<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
/*************************
* 字符串方法
* ************************/
var string = '123456';

 string.charAt(pos)
/*作用：
 返回指定位置字符
 参数：
 pos：位置，从0开始，0是第一位
 返回值：string
 1.要到了，返回那一位字符
 2.没找到，返回空字符串
 */

 string.charCodeAt(pos)
/*作用：
 返回字符串指定位置的unicode
 参数：
 pos：指定位置，从0开始
 返回值：number
 1.返回指定位置字符的unicode
 *      2.没找到，返回NaN
 *
 *  常用的
 * 		a-z:97-122
 *      A-Z:65-90
 *      0-9:48-57
 * */

 String.fromCharCode(u)
/*作用：
 返回指定unicode对应的字符
 参数：
 u:unicode
 返回值：string
 返回指定unicode对应的字符
 *
 * */

 string.indexOf(s,[pos])
/*作用：
 查找指定字符在字符串中第一次出现的位置
 参数：
 s:指定字符,可以是1个也可以是多个连续字符，string
 [pos]:可选，number,从哪一位开始查看，默认是0
 返回值：number
 1.找到，返回指定字符第一位字符所在的位置数字下标
 2.没找到，返回-1
 3.从左往右查找
 4.只返回第一次出现的位置
 * */

 string.lastIndexOf(s,[pos])
/*作用：
 查找指定字符在字符串中第一次出现的位置
 参数：
 s:指定字符,可以是1个也可以是多个连续字符，string
 [pos]:可选，number,从哪一位开始查看，默认是最后一位
 返回值：number
 1.找到，返回指定字符第一位字符所在的位置数字下标
 2.没找到，返回-1
 3.从右往左查找
 4.只返回第一次出现的位置
 * */

 string.slice(start,[end]);
/*作用：
 截取指定范围的字符片段
 参数：
 start:起始位置
 [end]:可选，终止位置，默认最后一位
 返回值：string
 1.不传参数，返回完整字符串
 *      2.截取到，返回截取到的字符串
 * 		3.没截取到，返回空字符串
 * 		4.负数，字符串长度+负数
 *      5.截取后不改变原字符串，返回的是新字符串
 *      6.不包含结束位置
 * */

 string.substring(start,[end])
/*作用：
 截取指定范围的字符片段
 参数：
 start:起始位置
 [end]:可选，终止位置，默认最后一位
 *  返回值：string
 1.不传参数，返回完整字符串
 *      2.截取到，返回截取到的字符串
 * 		3.没截取到，返回空字符串
 * 		4.负数转成0
 *      5.截取后不改变原字符串，返回的是新字符串
 *      6.end<start，会自动换过来
 *      7.不包含结束位置
 *      8.结束位置-起始位置=截取个数
 * 7、8哪种理解都可以
 * */

 string.substr(start,[length])
/*作用：
 截取指定范围的字符片段
 参数：
 start:起始位置
 [length]:截取个数，默认截取到最后一位
 *  返回值：string
 1.不传参数，返回完整字符串
 *      2.截取到，返回截取到的字符串
 * 		3.没截取到，返回空字符串
 * 		4.负数，字符串长度+负数
 *      5.截取后不改变原字符串，返回的是新字符串
 * */

 string.split(s)
/*作用：
 用指定字符分隔字符串，把结果放到数组里返回
 参数：
 s:分隔符
 返回值：array
 1.不传参，完整字符串作为一项放到数组里返回
 2.分隔符是空字符串，字符串的每个字符作为一项，放到数组里
 3.用字符串中有的字符分隔，分隔的结果放到数组里
 4.如果用第一位或者最后一位分隔，会有空字符串
 5.用字符串中没有的字符分隔，完整的字符串作为一项放数组里

 只有空字符串切割空字符串才会出现空数组
 别的用整个作为分隔符分隔，那么结果为['','']
 *
 * */

 string.trim()
 /* 作用：
 * 		ES5方法，去除前后空格
 * */

 string.toUpperCase()
/*作用：
 字符串每个字符转成大写
 * */

 string.toLowerCase()
/*作用：
 字符串每个字符转成小写
 * */

 string.includes(s)
/*作用：
 ES6，字符串中是否有指定字符
 参数：
 s：指定字符
 返回值：boolean
 1.有，true
 2.没有,false
 *
 * */

 string.startsWith(s,[pos])
/* * 作用：
 * 	  ES6，是否以指定字符开始
 * 参数：
 * 	s:指定字符
 * [pos]:可选，位置，默认是0
 * 返回值：boolean
 * 		1.是,true
 *      2.不是，false
 * */

 string.endsWith(s,[pos])
/** 作用：
 * 	  ES6，是否以指定字符结束
 * 参数：
 * 	s:指定字符
 * [pos]:可选，位置，默认是最后一位,不包含结束位置
 * 返回值：boolean
 * 		1.是,true
 *      2.不是，false
 * */


/************************
 * 数组方法
 * ***********************/
var array = [1, 2, 3];

 array.join([p])
/* 作用：
 数组的每一项用拼接符拼成一个字符串返回
 参数：
 [p]：可选，拼接符，默认是逗号
 *  返回值：string
 * 		1.不传参，每一项用逗号拼接
 *      2.拼接符是空字符串，每一项直接拼接
 *      3.拼接符拼接返回
 * */

 array.push(val1,val2...);
/*作用：
 向数组的最后添加数据
 参数：
 添加的数据，多个数据间用逗号分隔
 返回值：number
 新数组的长度（多少个数据）
 *
 * */

 array.pop()
/** 作用：
 * 	   删除数组最后一个数据
 * 返回值：混合
 * 	  删除的那一个数据
 * */

 array.shift()
/** 作用：
 * 	   删除数组第一位数据
 * 返回值：混合
 * 	  返回删除的那一个数据
 * */

 array.unshift(val1,val2...)
/*作用：
 向数组的头部添加数据
 参数：
 添加的数据，多个数据之间用逗号分隔
 返回值：number
 新数组的长度
 * */

 array.indexOf(target,[start])
/*作用：
 从指定位置开始查找数组里是否有指定值
 参数：
 target：要找的值
 [start]:可选，起始位置，默认是0
 返回值：number
 1.找到返回位置下标
 2.没找到返回-1
 3.从左向右
 * */

 array.lastIndexOf(target,[start])
/*作用：
 从指定位置开始查找数组里是否有指定值
 参数：
 target：要找的值
 [start]:可选，起始位置，默认是最后一位
 返回值：number
 1.找到返回位置下标
 2.没找到返回-1
 3.从右向左
 * */

 array.includes(target)
/** 作用：
 * 		数组里是否包含指定值
 * 参数：
 * 	target:指定值
 * 返回值：boolean
 * 		1.有,true
 *      2.没有,false
 *      3.===
 * */

 array.slice(start,[end])
/* 作用：
 截取数组中的一段数据放新数组里返回
 参数：
 start：起始位置
 [end]:终止位置，可选，默认到最后一位
 返回值：array
 1.不传参数，返回完整新数组
 2.截取起始位置到终止位置的数据，不包含终止位置，放新数组里返回
 3.负数，长度+负数
 * */

 array.splice(pos,length,val1,val2...)
/*作用：
 添加，删除，替换
 参数：
 pos:位置
 length:删除长度
 val1,val2:添加数据，多个用逗号分隔
 添加数据时：length为0
 返回值：array
 1.如果有删除，把删除项放到数组里返回
 2.没删除，返回空数组
 3.操作的是原数组
 * */

 array.concat(val1,val2...)
/** 作用：
 * 		原数组和传入值放新数组里返回，连接2个数组
 * 参数：
 * 	val1,val2:添加的数据，多个之间用逗号
 * 返回值：array
 * 		1.原数组和新传入的值放到新数组里返回
 *      2.不改变原数组
 *      3.如果传入的是数组，会把原数组每项和传入数组的每项放到新数组里返回
 * */

 array.reverse()
/*作用：
 数组数据前后颠倒顺序排序
 *  返回值：array
 * 		排序后的原数组
 * */


 array.sort([fn])
/*作用：
 数组每项排序
 参数:
 [fn]:处理函数，根据return后边的结果，>0,<0
 返回值：array
 1.排序后的原数组
 2.不传参数，按字符的ASCII码的大小排序
 3.传入处理函数，根据return的结果排序
 //从小到大
 return a-b;

 //从大到小
 return b-a;

 //随机
 return Math.random()-0.5
 * */


 Array.from(arr)
/** 作用：
 ES6，把类数组，或者有length的对象转成真正的数组
 * 参数：
 * 	  arr:类数组，或者有length对象，类数组：arguments，获取元素tag,class
 * */



 array.forEach(fn,[this])
/* 循环，遍历，迭代
    作用：
 * 		遍历数组
 * 参数：
 * 		fn：处理函数
 *     [this]:可选，处理函数的this指向
 *
 * function(value,index,arr){}
 * value:数组每项值
 * index:索引
 * arr:数组
 *
 *	不可以break和continue
 *  可以return
 * */


array.every(fn,[this])
/* * 作用：
 * 		每次都满足判断条件返回true，有一个不满足就返回false
 * 参数：
 * 		fn：处理函数
 *     [this]:可选，处理函数的this指向
 *
 * function(value,index,arr){}
 * value:数组每项值
 * index:索引
 * arr:数组
 *
 * return  判断条件
 * */


array.some(fn,[this])
/** 作用：
 * 		有一个满足判断条件返回true，都不满足就返回false
 * 参数：
 * 		fn：处理函数
 *     [this]:可选，处理函数的this指向
 *
 * function(value,index,arr){}
 * value:数组每项值
 * index:索引
 * arr:数组
 *
 * return  判断条件
 * */


array.map(fn,[this])
/** 作用：
 * 		每次循环return后的执行结果成为每项，返回新数组
 * 参数：
 * 		fn：处理函数
 *     [this]:可选，处理函数的this指向
 *
 * function(value,index,arr){}
 * value:数组每项值
 * index:索引
 * arr:数组
 *
 * return  执行语句
 * */

array.filter(fn,[this])
 /* 作用：
 * 		满足条件的项放到新数组里返回，没有满足项返回空数组
 * 参数：
 * 		fn：处理函数
 *     [this]:可选，处理函数的this指向
 *
 * function(value,index,arr){}
 * value:数组每项值
 * index:索引
 * arr:数组
 *
 * return  判断条件
 * */


 array.find(fn,[this])
/** 作用：
 * 		满足条件的第一项返回，没有满足项返回undefined
 * 参数：
 * 		fn：处理函数
 *     [this]:可选，处理函数的this指向
 *
 * function(value,index,arr){}
 * value:数组每项值
 * index:索引
 * arr:数组
 *
 * return  判断条件
 * */


 array.findIndex(fn,[this])
/* * 作用：
 * 		返回满足条件的第一项的下标，如果没有满足项返回-1,ES6
 * 参数：
 * 		fn：处理函数
 *     [this]:可选，处理函数的this指向
 *
 * function(value,index,arr){}
 * value:数组每项值
 * index:索引
 * arr:数组
 *
 * return  判断条件
 * */


 array.fill(val,[start],[end])
/*作用：
 数组里的项用指定值填充(替换)
 参数：
 val：要变成的值
 [start]：起始位置，可选，默认是0
 [end]:结束位置，可选，默认是最后一位
 返回值：array
 返回填充后的原数组
 * */


 array.copyWithin(pos,[start],[end])
/*作用：
 ES6，复制范围内的数据，从要替换位置开始替换，复制到几个，就替换几个

 * 参数：
 * 	pos:要替换的位置
 *  [start]:复制数据的起始位置，默认是0
 *  [end]:复制数据的结束位置，默认是最后一位
 * */

 for of
 /* ES6,专门遍历数组用的
 只遍历数组内，数组上的自定义属性和原型上的属性不会被遍历

 for in专门遍历对象{}
 for of专门遍历数组
 * */


  Array.isArray(array)
/*检测arr是不是数组
  是数组返回true,不是返回false
  * */


/******************************
* 数学方法
* ******************************/

 Math.PI	            //圆周率
 Math.abs()             //绝对值
 Math.cos()             //余弦
 Math.sin()             //正弦
 Math.tan()             //正切
 Math.ceil()            //向上取整
 Math.floor()           //向下取整
 Math.random()          //0~1之间的随机小数，不包含0和1
 Math.round()           //四舍五入
 Math.pow(a,b)          //a的b次方
 Math.sqrt(a,b)         //a开b次方
 Math.max(n1,n2...)     //最大值
 Math.min(n1,n2...)     //最小值


/*******************************
* JSON方法
* *******************************/

/*
 JSON
 JavaScript Object Notation
 数据交换格式
 长得像对象的字符串
 两种规格'{}','[]'
 属性名必须是双引号
 不能写undefined

 字符串必须双引号
 数字,布尔值，null,对象
*/

 JSON.parse()
 //JSON字符串转对象
 JSON.stringify()
//对象转JSON字符串

/*******************************
 * DOM方法
 * *******************************/
var div = document.getElementsByClassName('div')[0]
div.firstChild
//第一个子节点
div.lastChild
//最后一个子节点
div.nextSibling
//下一个兄弟节点
div.previousSibling
//上一个兄弟节点

div.childNodes
//所有第一级子节点
div.children
//所有第一级子元素节点
div.parentNode
//父级节点
div.firstElementChild
//第一个元素子节点
div.lastElementChild
//最后一个元素子节点
div.nextElementSibling
//下一个兄弟元素节点
div.previousElementSibling
//上一个元素兄弟节点

div.getAttribute('id');
/*
 第三种属性操作方式
 获取属性值
 getAttribute('属性名')
 设置属性值
 setAttribute('属性名',值)

 id,class可以操作，js加的自定义属性获取不到是null,行间的自定义属性可以操作
 .和[]可以操作id,class，js自定义属性，不能操作行间自定义属性

 行间的自定义属性必须用getAttribute，变量必须用[]，其他的都用.
 * */

var div = document.createElement('div');
/*
 新建节点
 *
 * 	新建的节点没有插入到html的某个节点下，页面就没有新建的这个节点
 *
 * 新建元素节点
 * 	document.createElement('标签名')
 * 必须写document
 * 创建属性节点
 * document.createAttribute()
 * 创建文本节点
 *  document.createTextNode()
 * */

document.appendChild(div);
/*
 插入节点
 父节点.appendChild(要插入的节点)
 向父节点的最后一位插入子节点
 如果是已有节点，相当于剪切
 返回新插入的那个节点
 * */

document.insertBefore(div,div1);
/*
 插入节点
 父节点.insertBefore(要插入的节点,参照节点)
 在参照节点前插入要插入的节点

 1.参照节点必须是父节点下的，不然会报错
 2.参照节点是null,相当于appendChild
 3.如果插入已有节点，相当于剪切
 * */

document.removeChild(div);
/*
 删除节点
 父节点.removeChild(要删除的节点)
 * 		从父级下删除节点
 * 		返回删除的那个节点
 * */

document.replaceChild(div,div1);
/*
 替换节点
 * 	父级.replaceChild(要插入的节点,要被替换的节点)
 *  要插入的节点替换要被替换的节点
 * 如果要插入的是已有节点，相当于剪切
 * 返回：被替换的那个节点
 * */

div.cloneNode();
/*
 * 克隆节点
 * 	节点.cloneNode(参数)
 * 	只克隆结构，不克隆自定义属性，绑的事件函数		 *
 *
 * 	参数：默认是false
 * 	false:
 *  浅克隆，只克隆本身标签，行间属性
 *  true:
 * 	深克隆，还包括子内容和子标签
 * */

/*******************************
 * DOM方法--获取元素位置
 * *******************************/
var div = document.getElementById('div');
div.offsetParent
/*
 * 元素.offsetParent
 *   定位父级
 *   1.自身有没有定位都可以
 *   2.没有定位父级，是body
 *   3.body的定位父级是Null
 * */

div.offsetLeft
/*
 * 元素.offsetLeft
 *   自身左外边界到定位父级的左内边界距离，不带单位
 * */

div.offsetTop
/*
 * 元素.offsetTop
 *   自身上外边界到定位父级的上内边界距离，不带单位
 * */

div.getBoundingClientRect()
/*
 *   元素.getBoundingClientRect()
 *       元素到可视区域的尺寸，对象，不带单位
 *       top,bottom,left,right,width,height
 *
 *       right,bottom是元素右，下边框外到可视区左，上的距离，left+width+border
 *       width,height是加上border的尺寸，元素实际占位尺寸，width+padding+border
 * */

document.body.clientWidth
/*
 元素.clientWidth
 * 可视区宽度，不带单位，只跟窗口有关，与内容无关
 * 拿不到行级元素宽高
 * width + padding
 * 不带border
 * */

document.documentElement.clientHeight
/*
 元素.clientHeight
 * 可视区宽度，不带单位，只跟窗口有关，与内容无关
 * 获取窗口高度只能用documentElement获取，用body会出错
 * 拿不到行级元素宽高
 * width + padding
 * 不带border
 * */

div.offsetWidth / div.offsetHeight
/*
 * 元素实际尺寸，占位尺寸
 * width + padding + border
 * 可以拿到行级宽高
 * */

div.scrollHeight / div.scrollWidth
/*
 *   内容高度
 *   当内容没有超出，clientHeight相等
 *   内容有超出，clientHeight + 超出部分
 * */

document.body.scrollTop
/*
* 滚动条距离顶部距离
* 设置：
*   document.body.scrollTop = 1000; 不带单位
* 获取：
*   document.body.scrollTop
*
* chrome下使用body，
* 其他浏览器使用documentElement
* */


/*******************************
 * 表格方法
 * *******************************/
var tab = document.getElementsByTagName('table')[0];
tab.tHead
//表头

tab.tBodies[0]
//表身

tab.tFoot
//表尾

tab.rows
//行

tab.cells
//列

tab.createTHead()
//新建表头

tab.createTBody()
//新建表身

tab.createTFoot()
//新建表尾巴

tab.insertRow()
/*
* insertRow([pos])  行
*  pos:插入到第几行前，num
*  不写参数，默认插入到最后一位
* */

tab.insertCell()
/*
* insertCell([pos])  列
*  pos:插入到第几列前，num
*  不写参数，默认插入到最后一位
* */

tab.deleteRow()
/*
 * deleteRow([pos])  删除行
 *  pos:删除第几个
 * */

tab.deleteCell()
/*
 * deleteRow([pos])  删除列
 *  pos:删除第几个
 * */

/*******************************
 * 表单方法
 * *******************************/
var form = document.getElementsByTagName('form')[0];
form.name
/*
* <input type="text" name="txt"/>
* 写在form下的input，通过input的name 可以直接获取到input
* */

/*******************************
 * BOM方法
 * *******************************/
//DOM方法在window下使用

open(URL,name,style,boolean);
/*
 * 前两个为常用参数，返回值为新打开的窗口
 * 参数：
 *   URL：跳转地址，网址前必须加http://
 *   name:打开方式，框架name,默认新窗口打开
 *       _blank:新窗口打开
 *       _self:自身窗口打开
 *       _top:最外层框架打开
 *       _parent:父级框架
 *       name:iframe的name
 *   style:新打开窗口的样式，不常用
 *   boolean:历史记录，不常用
 *  top:最外层框架的window，对象
 *  parent:父级框架的window,对象
 * */

close();
/*
 * 关闭窗口
 * 在火狐下只能关闭用open打开的窗口
 * */

innerWidth/innerHeight
/*
 * 可视区宽高，直接使用
 * 不考虑兼容性
 *   用innerWidth,比如移动端
 * 考虑兼容性
 *   用document.documentElement.clientWidth
 * */

pageXOffset/pageYOffset
/*
 * 获取滚动条的距离
 * */

scrollTo(x,y)
/*
 * 设置滚动条的距离
 *   参数
 *       x：x轴
 *       y：y轴
 * */

location
/*
* 地址栏信息
* href：地址栏
* search:查询信息
*   地址栏？后面到#号前面的信息，会带？
* hash:锚信息
*   地址栏#后面的信息
*
* onhashchange  当hash改变时触发的事件
* 除了设置hash，其他都会刷新页面，注意别放在全局，不然会无线刷新
* */

history
/*
* 历史记录
* back() 后退
* foward()前进
* */

screen
/*
* 对象，分辨率尺寸（了解）
* */

navigator
/*
* 代理信息（判断浏览器使用）
* userAgent:浏览器信息，版本号，内核
* */


/*******************************
 * 事件
 * *******************************/

//鼠标事件
obj.onclick
/*
* 点击事件
* */

obj.onmouseover
/*
* 鼠标滑入事件（包括子级）
* */

obj.onmouseout
/*
* 鼠标滑出事件（包括子级）
* */

obj.onmouseenter
/*
* 鼠标滑入事件
* */

obj.onmouseleave
/*
* 鼠标滑出事件
* */

obj.onmousemove
/*
* 鼠标在元素上面移动时触发
* 和鼠标移动距离没有关系，和时间有关系
* */

obj.onmousedown
/*
 *   鼠标按下事件
 * */

obj.onmouseup
/*
 *   鼠标抬起事件
 * */

obj.ondblclick
/*
 *   鼠标双击事件
 * */

obj.onmousewheel
/*
* 鼠标滚轮事件
* */

window.onresize
/*
 * 事件，当窗口尺寸发生改变时
 * */

window.onscroll
/*
 * 滚动条滚动式触发
 * */
window.onhashchage
/*
* 当页面hashchange改变时触发的事件
* */



/*******************************
 * event 事件流
 * *******************************/

/*
* 事件机制
* 1.捕获
* 2.目标
* 3.冒泡
* */

div.addEventListener();
/*
 * div.addEventListener('事件名',function,bloon)
 * 事件监听器绑定事件
 *   参数：
 *       布尔值：
 *           是否在捕获阶段执行
 *           true：捕获执行
 *           false：冒泡执行
 * 1.在移动端全部用addEventListener绑定事件，不用on
 * 2.用on绑定事件，同意元素的同一事件只能绑定一个函数，后绑的会覆盖前绑的
 * 3.用addEventlistener绑定事件，同一元素同一事件，相同函数只能绑1个，不同函数可以绑多个
 * 4.想解绑就用有名函数，匿名函数不能解绑
 *
 * 如果事件函数是有名的，那么后面的会覆盖前面的
 * 如果事件函数时匿名的，是会执行的，当目标元素有多个同样的事件，但是不同形态时（捕获或冒泡）时，执行的顺序，走先绑先执行（不管捕获或者冒泡）
 * */

div.removeEventListener();
/*
* div.removeEventListener()
* 事件监听器解绑事件
*   解绑事件需要满足4个条件
*   1.同一元素
*   2.同一事件
*   3.同一 函数
*   4.同一过程（捕获阶段或者冒泡阶段）
* */

ev.cancelBubble  = true;
ev.stopPropagation();
/*
* 阻止冒泡
* 方法一：
*   ev.cancelBubble  = true;
*   默认属性为false，只能阻止冒泡，不能阻止捕获
* 方法二：
*   ev.stopPropagation();
*   阻止后续进程，冒泡和捕获都可以阻止
* 必须是相同事件，才能阻止冒泡
* */


document.onmousedown = function () {
//    return false;
    ev.preventDefault();
}
/*
* 阻止浏览器默认行为，拖拽行为
*
* 在事件监听器下只能用ev.preventDefaule();
* */

//鼠标事件对象
ev.altKey
ev.shiftKey
ev.ctrlKey
/*
* 鼠标点击时是否按下alt,shift,ctrl
* true：按下
* false:没按下
* */

ev.clientX/ev.clientY
/*
* 鼠标位置到可视区左/上的距离
* */

ev.offsetX/ev.offsetY
/*
* 鼠标位置到元素的左/上的距离
* */
</script>
</body>
</html>